<h1>Time & Space Complexity</h1>

<h2>Order Complexity Analysis</h2>
<h3>Amount of Space or Time taken up by an algorithm/code as function of input size.<br />
    NOT actual time taken.</h3>
<hr>
<h3>Big O Notation</h3>
<h4>Represents the upper bound of an algorithm's complexity.<br />
    Focuses on the worst-case scenario.<br />
    Ignores constant factors and lower-order terms.<br />
    f(n) &le; O(g(n))</h4>
<hr>
<h3>Big Omega Notation</h3>
<h4>Represents the lower bound of an algorithm's complexity.<br />
    Focuses on the best-case scenario.<br />
    Ignores constant factors and lower-order terms.<br />
    f(n) &ge; Ω(g(n))</h4>
<hr>
<h3>Big Theta Notation</h3>
<h4>Represents the average bound of an algorithm's complexity.<br />
    Focuses on both best-case and worst-case scenarios.<br />
    Ignores constant factors and lower-order terms.<br />
    f(n) = Θ(g(n))</h4>
<hr>
<h3>Small O, Omege, Theta Notation</h3>
<h4>Represents a loose upper bound, lower bound, and average bound respectively where on otjer hand Big O, Omege, Theta
    Notation represents tight bound.<br />
    For e.g.: A normal person's height is compared like it's less than 1km and more than 1cm(loose bound) and it's less
    than 7ft and more than 4ft.<br />
    f(n) &lt; o(g(n))<br />
    f(n) &gt; ω(g(n))<br />
    f(n) ~ θ(g(n))</h4>
<hr>
<h2>Common Time Complexities</h2>
<ul>
    <li>O(1) - Constant Time</li>
    <li>O(log n) - Logarithmic Time</li>
    <li>O(n) - Linear Time</li>
    <li>O(n log n) - Linearithmic Time</li>
    <li>O(n^2) - Quadratic Time</li>
    <li>O(2^n) - Exponential Time</li>
    <li>O(n!) - Factorial Time</li>
</ul>
<hr>
<h2>Common Space Complexities</h2>
<h3>We analyze auxiliary space</h3>
<ul>
    <li>O(1) - Constant Space</li>
    <li>O(n) - Linear Space</li>
    <li>O(n^2) - Quadratic Space</li>
    <li>O(log n) - Logarithmic Space</li>
</ul>
<hr>